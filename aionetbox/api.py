
import re
import json
import asyncio
import aiohttp
import logging
import collections

from urllib.parse import urlencode
from prance import ResolvingParser

from aionetbox.exceptions import (
    BadRequest,
    MissingRequiredParam,
    InvalidResponse,
)

log = logging.getLogger(__name__)


class AIONetbox(object):
    _http_methods = ['get', 'post', 'put', 'patch', 'delete']
    _api_cache = {}

    @classmethod
    def from_openapi(cls, url, api_key, session=None):
        data = ResolvingParser('{}/api/swagger.json'.format(url))

        aionb = cls(url, api_key, spec=data, session=session)

        return aionb

    @classmethod
    def from_spec(cls, spec, api_key, session=None):
        data = ResolvingParser(spec)

        url = '{}://{}'.format(data.specification.get('schemes', ['http'])[0], data.specification.get('host'))
        aionb = cls(url, api_key, spec=data, session=session)

        return aionb

    def __init__(self, host, api_key, spec=None, session=None, loop=None):
        self.host = host
        self.api_key = api_key
        self.session = session or aiohttp.ClientSession()
        self.config = self.parse_spec(spec)
        self.tags = self.config.keys()

    async def request(self, method, url, query_params=None, headers=None, body=None, post_params=None, _timeout=None):
        method = method.upper()
        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS']

        if post_params and body:
            raise ValueError(
                'body parameter cannot be used with post_params parameter.'
            )

        post_params = post_params or {}
        headers = headers or {}
        headers.update({
            'Authorization': 'Token {}'.format(self.api_key)
        })
        timeout = _timeout or 5 * 60

        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'

        args = {
            'method': method,
            'url': url,
            'timeout': timeout,
            'headers': headers
        }

        if query_params:
            args['url'] += '?' + urlencode(query_params)

        if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
            if re.search('json', headers['Content-Type'], re.IGNORECASE):
                if body is not None:
                    body = json.dumps(body)
                args['data'] = body
            elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
                args['data'] = aiohttp.FormData(post_params)
            elif headers['Content-Type'] == 'multipart/form-data':
                # must del headers['Content-Type'], or the correct
                # Content-Type which generated by aiohttp
                del headers['Content-Type']
                data = aiohttp.FormData()
                for param in post_params:
                    k, v = param
                    if isinstance(v, tuple) and len(v) == 3:
                        data.add_field(
                            k,
                            value=v[1],
                            filename=v[0],
                            content_type=v[2]
                        )
                    else:
                        data.add_field(k, v)
                args['data'] = data

            # Pass a `bytes` parameter directly in the body to support
            # other content types than Json when `body` argument is provided
            # in serialized form
            elif isinstance(body, bytes):
                args['data'] = body
            else:
                # Cannot generate the request from given parameters
                msg = '''Cannot prepare a request message for provided arguments. Please check that your
                         arguments match declared content type.'''
                raise Exception(msg)

        return await self.session.request(**args)

    def parse_spec(self, config):
        operations = {}

        if not config:
            return {}

        if isinstance(config, ResolvingParser):
            config = config.specification

        operations['_orig'] = config
        for path, data in config.get('paths', {}).items():
            for action in self._http_methods:
                if action not in data:
                    continue

                payload = data.get(action, {})
                tags = payload.get('tags', [])

                for tag in tags:
                    if tag not in operations:
                        operations[tag] = {}

                    rest_cfg = {
                        'url': path,
                        'params': data.get('parameters', []),
                        'method': action,
                    }

                    operations[tag][payload.get('operationId')] = payload
                    operations[tag][payload.get('operationId')]['rest'] = rest_cfg

        return operations

    def __getattr__(self, tag):
        if tag not in self.tags:
            raise AttributeError("'{}' object has no attribute '{}'".format(__name__, tag))

        if tag in self._api_cache:
            return self._api_cache.get(tag)

        c = NetboxApi(tag, self.config.get(tag), self)
        self._api_cache[tag] = c

        return c

    async def close(self):
        await self.session.close()

    def __del__(self):
        asyncio.ensure_future(self.session.close())


class NetboxApi(object):

    def __init__(self, tag, operations, client):
        self.name = tag
        self.config = operations
        self.operations = operations.keys()
        self.client = client

        self._operation_cache = {}

    def __getattr__(self, operation):
        if operation not in self.operations:
            raise AttributeError("'{}' object has no attribute '{}'".format(__name__, operation))

        if operation in self._operation_cache:
            return self._operation_cache.get(operation)

        m = NetboxApiOperation(self.name, operation, self.config.get(operation), self.client)
        self._operation_cache[operation] = m

        return m


class NetboxApiOperation(object):

    def __init__(self, tag, operation, config, client):
        self.client = client
        self.config = config
        self.rest_config = self.config.get('rest', {})
        self.operation = operation
        self.tag = tag

    async def request(self, **kwargs):

        path, body, query = self.parse_params(kwargs)

        if self.operation_method == 'list':
            # netbox has terrible swagger spec generation and leaves out custom fields (cf)
            keys_used = set(list(body.keys()) + list(query.keys()) + list(path.keys()))
            remaining_vars = set(kwargs.keys()) - keys_used

            for kw in remaining_vars:
                if kw.startswith('cf_'):
                    query[kw] = kwargs.get(kw)

        url = self.build_url(self.rest_config.get('url')).format(**path)

        resp = await self.client.request(
            method=self.rest_config.get('method'),
            url=url,
            query_params=query,
            body=body
        )

        resp.raise_for_status()
        data = await resp.json()
        return NetboxResponseObject.from_response(
            data=data,
            **self.config.get('responses', {}).get(str(resp.status), {}).get('schema')
        )

    def build_url(self, url):
        return '{}{}{}'.format(self.client.host, self.client.config.get('_orig', {}).get('basePath'), url)

    def parse_params(self, params):
        qb = {
            'body': {},
            'query': {},
            'path': {},
        }

        spec_parameters = self.config.get('parameters', []) + self.rest_config.get('params', [])
        for sp in spec_parameters:
            if sp['name'] not in params and sp['required']:
                raise MissingRequiredParam('{} is a required parameter'.format(sp['name']))

            if sp['name'] not in params:
                continue

            qb[sp['in']][sp['name']] = params.get(sp['name'])

        return (qb.get('path'), qb.get('body'), qb.get('query'))

    @property
    def operation_method(self):
        if self.operation.endswith('partial_update'):
            return 'partial_update'

        return self.operation.split('_')[-1]

    async def __call__(self, **kwargs):
        try:
            return await self.request(**kwargs)
        except MissingRequiredParam as e:
            raise AttributeError(str(e))
        except aiohttp.ClientResponseError as e:
            raise BadRequest('{} failed with code {}: {}'.format(self.operation, e.status, e.message))

    def __repr__(self):
        pass

    def __str__(self):
        pass


class NetboxResponseObject(object):

    @classmethod
    def from_response(cls, type, data, **kwargs):
        output = cls()
        if type != 'object':
            return data

        required = kwargs.get('required', [])
        properties = kwargs.get('properties', {})

        for req in required:
            # Check for all required response parameters
            if req not in data:
                raise InvalidResponse('Response did not include required "{}"'.format(req))

        # if type == 'array':
        #     return [] # What if the root object is an array?

        # Iterate over every datapoint and further parse if required
        for key, val in data.items():
            spec = properties.get(key, {})
            ctype = spec.get('type')
            value = val

            if ctype == 'object':
                if isinstance(val, collections.Mapping):
                    value = cls.from_response(data=val, **spec)
            elif ctype == 'array':
                # If we have an array of objects, make sure the value is iterable, then produce a list of objects
                try:
                    iter(val)
                    value = [cls.from_response(data=v, **spec.get('items')) for v in val]
                except TypeError:
                    pass

            setattr(output, key, value)

        return output

    def __repr__(self):
        return '{}'.format(self.__dict__)
